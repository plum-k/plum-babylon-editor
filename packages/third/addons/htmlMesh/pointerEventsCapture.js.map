{"version":3,"file":"pointerEventsCapture.js","sourceRoot":"","sources":["../../../../dev/addons/src/htmlMesh/pointerEventsCapture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tools } from \"core/Misc/tools\";\r\n\r\n// A capture management system to ensure that the correct object has the pointer\r\n// events by eliminating race conditions that can cause the pointer events to be\r\n// released by a different object after they are captured leaving no object\r\n// as the owner.  It does this by queueing requests and only allowing\r\n// capture when the current capture owner releases pointer events.\r\n\r\ntype CaptureReleaseCallback = () => void;\r\n\r\ntype CaptureReleaseCallbacks = {\r\n    capture: CaptureReleaseCallback;\r\n    release: CaptureReleaseCallback;\r\n};\r\n\r\nlet captureRequestQueue: string[] = [];\r\n\r\n// Key is request id, value is object with capture and release callbacks\r\nconst pendingRequestCallbacks: Map<string, CaptureReleaseCallbacks> = new Map();\r\n\r\n// Keep track of release requests with no matching capture request\r\n// in case the release request arrived before the capture to avoid\r\n// the capture request never getting released.\r\nlet unmatchedReleaseRequests: string[] = [];\r\n\r\nlet currentOwner: string | null = null; // Called on first capture or release request\r\n\r\n/**\r\n * Get the id of the object currently capturing pointer events\r\n * @returns The id of the object currently capturing pointer events\r\n * or null if no object is capturing pointer events\r\n */\r\nexport const getCapturingId = () => {\r\n    return currentOwner;\r\n};\r\n\r\n/**\r\n * Request that the object with the given id capture pointer events.  If there is no current\r\n * owner, then the request is granted immediately.  If there is a current owner, then the request\r\n * is queued until the current owner releases pointer events.\r\n * @param requestId An id to identify the request.  This id will be used to match the capture\r\n * request with the release request.\r\n * @param captureCallback The callback to call when the request is granted and the object is capturing\r\n * @param releaseCallback The callback to call when the object is no longer capturing pointer events\r\n */\r\nexport const requestCapture = (requestId: string, captureCallback: CaptureReleaseCallback, releaseCallback: CaptureReleaseCallback) => {\r\n    debugLog(`In pointerEventsCapture.requestCapture - Pointer events capture requested for ${requestId}`);\r\n\r\n    // If there is a release for this request, then ignore the request\r\n    if (removeUnmatchedRequest(requestId)) {\r\n        debugLog(`In pointerEventsCapture.requestCapture - Capture request matched previous release request ${requestId}.  Cancelling capture request`);\r\n        return;\r\n    } else if (requestId !== currentOwner) {\r\n        // if the request is not already in the queue, add it to the queue\r\n        enqueueCaptureRequest(requestId, captureCallback, releaseCallback);\r\n    }\r\n\r\n    if (!currentOwner) {\r\n        // If there is no current owner, go ahead and grant the request\r\n        transferPointerEventsOwnership();\r\n    }\r\n    // If the request id is the current owner, do nothing\r\n};\r\n\r\n/**\r\n * Release pointer events from the object with the given id.  If the object is the current owner\r\n * then pointer events are released immediately.  If the object is not the current owner, then the\r\n * associated capture request is removed from the queue.  If there is no matching capture request\r\n * in the queue, then the release request is added to a list of unmatched release requests and will\r\n * negate the next capture request with the same id.  This is to guard against the possibility that\r\n * the release request arrived before the capture request.\r\n * @param requestId The id which should match the id of the capture request\r\n */\r\nexport const requestRelease = (requestId: string | null) => {\r\n    debugLog(`In pointerEventsCapture.requestRelease - Pointer events release requested for ${requestId}`);\r\n\r\n    // if the requestId is the current capture holder release it\r\n    if (!requestId || requestId === currentOwner) {\r\n        transferPointerEventsOwnership();\r\n    } else if (cancelRequest(requestId)) {\r\n        // if the request is in the queue, but not the current capture holder, remove it and it's callbacks\r\n        pendingRequestCallbacks.delete(requestId);\r\n    } else {\r\n        debugLog(`In pointerEventsCapture.requestRelease - Received release request ${requestId} but no matching capture request was received`);\r\n        // request was not current and not in queue, likely because we received a release\r\n        // request before the capture.  Add it to the unmatched list to guard against this possibility\r\n        if (!unmatchedReleaseRequests.includes(requestId)) {\r\n            unmatchedReleaseRequests.push(requestId);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Relase pointer events from the current owner\r\n */\r\nexport const releaseCurrent = () => {\r\n    requestRelease(currentOwner);\r\n};\r\n\r\nconst enqueueCaptureRequest = (requestId: string, capture: CaptureReleaseCallback, release: CaptureReleaseCallback) => {\r\n    debugLog(`In pointerEventsCapture.enqueueCaptureRequest - Enqueueing capture request for  ${requestId}`);\r\n    if (!captureRequestQueue.includes(requestId)) {\r\n        captureRequestQueue.push(requestId);\r\n        pendingRequestCallbacks.set(requestId, { capture, release });\r\n    }\r\n};\r\n\r\n// Removes the request from the queue if it exists.  Returns true\r\n// if the request was found and removed, otherwise false\r\nconst cancelRequest = (requestId: string | null) => {\r\n    let removed = false;\r\n    captureRequestQueue = captureRequestQueue.filter((id) => {\r\n        if (id !== requestId) {\r\n            return true;\r\n        } else {\r\n            removed = true;\r\n            debugLog(`In pointerEventsCapture.cancelRequest - Canceling pointer events capture request ${requestId}`);\r\n            return false;\r\n        }\r\n    });\r\n    return removed;\r\n};\r\n\r\nconst removeUnmatchedRequest = (requestId: string) => {\r\n    let removed = false;\r\n    unmatchedReleaseRequests = unmatchedReleaseRequests.filter((id) => {\r\n        if (id !== requestId) {\r\n            return true;\r\n        } else {\r\n            removed = true;\r\n            return false;\r\n        }\r\n    });\r\n    return removed;\r\n};\r\n\r\nconst transferPointerEventsOwnership = () => {\r\n    const newOwnerId = nextCaptureRequest();\r\n    debugLog(`In pointerEventsCapture.transferPointerEventsOwnership - Transferrring pointer events from ${currentOwner} to ${newOwnerId}`);\r\n    // Release the current owner\r\n    doRelease();\r\n    if (newOwnerId) {\r\n        doCapture(newOwnerId);\r\n    }\r\n};\r\n\r\nconst doRelease = () => {\r\n    debugLog(`In pointerEventsCapture.doRelease - Releasing pointer events from ${currentOwner}`);\r\n    if (currentOwner) {\r\n        // call the release callback\r\n        pendingRequestCallbacks.get(currentOwner)?.release();\r\n        // And remove the callbacks\r\n        pendingRequestCallbacks.delete(currentOwner);\r\n        currentOwner = null;\r\n    }\r\n};\r\n\r\nconst doCapture = (newOwnerId: string) => {\r\n    if (newOwnerId) {\r\n        // call the capture callback\r\n        pendingRequestCallbacks.get(newOwnerId)?.capture();\r\n    }\r\n    currentOwner = newOwnerId;\r\n    debugLog(`In pointerEventsCapture.doCapture - Pointer events now captured by ${newOwnerId}`);\r\n};\r\n\r\nconst nextCaptureRequest = () => {\r\n    return captureRequestQueue.length > 0 ? captureRequestQueue.shift() : null;\r\n};\r\n\r\n// #region Debugging support\r\ndeclare global {\r\n    interface Window {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \"pointer-events-capture-debug\": boolean | null;\r\n    }\r\n}\r\n\r\nconst debugLog = (message: string) => {\r\n    // If we are runnning in a test runner (in node, so window is not defined)\r\n    // or if the debug flag is set, then log the message\r\n    if (typeof window === \"undefined\" || window[\"pointer-events-capture-debug\"]) {\r\n        Tools.Log(\r\n            `${performance.now()} - game.scene.pointerEvents - ${message}\\ncurrentOwner: ${currentOwner}\\nqueue: ${captureRequestQueue}\\nunmatched: ${unmatchedReleaseRequests}`\r\n        );\r\n    }\r\n};\r\n// #endregion Debugging support\r\n"]}