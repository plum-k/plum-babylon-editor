{"version":3,"file":"pointerEventsCaptureBehavior.js","sourceRoot":"","sources":["../../../../dev/addons/src/htmlMesh/pointerEventsCaptureBehavior.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,MAAM,EAAE,uCAAyB;AAC1C,OAAO,EAAE,cAAc,EAAE,cAAc,EAAE,cAAc,EAAE,cAAc,EAAE,MAAM,wBAAwB,CAAC;AAExG,sDAAsD;AACtD,IAAI,MAAM,GAAiB,IAAI,CAAC;AAEhC,4GAA4G;AAC5G,+FAA+F;AAC/F,IAAI,mBAAmB,GAAG,CAAC,CAAC;AAE5B,4EAA4E;AAC5E,4EAA4E;AAC5E,0DAA0D;AAC1D,MAAM,iBAAiB,GAAG,IAAI,OAAO,EAA8C,CAAC;AAEpF,MAAM,mBAAmB,GAAG,CAAC,KAAY,EAAE,EAAE;IACzC,yCAAyC;IACzC,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,CAAC;QAClC,OAAO;IACX,CAAC;IACD,IAAI,mBAAmB,KAAK,CAAC,EAAE,CAAC;QAC5B,QAAQ,CAAC,gBAAgB,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;QACxD,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;QACvD,MAAM,GAAG,MAAM,IAAI,KAAK,CAAC;QACzB,MAAM,CAAC,GAAG,CAAC,4EAA4E,CAAC,CAAC;QACzF,MAAM,CAAC,mBAAmB,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC;IACzD,CAAC;IACD,mBAAmB,EAAE,CAAC;AAC1B,CAAC,CAAC;AAEF,MAAM,oBAAoB,GAAG,GAAG,EAAE;IAC9B,QAAQ,CAAC,mBAAmB,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;IAC3D,QAAQ,CAAC,mBAAmB,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;IAC1D,MAAM,GAAG,IAAI,CAAC;IACd,MAAM,CAAC,GAAG,CAAC,4EAA4E,CAAC,CAAC;IACzF,mBAAmB,GAAG,CAAC,CAAC;AAC5B,CAAC,CAAC;AAEF,MAAM,kBAAkB,GAAG,GAAG,EAAE;IAC5B,yCAAyC;IACzC,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,CAAC;QAClC,OAAO;IACX,CAAC;IAED,uDAAuD;IACvD,IAAI,CAAC,MAAM,EAAE,CAAC;QACV,OAAO;IACX,CAAC;IAED,mBAAmB,EAAE,CAAC;IACtB,IAAI,mBAAmB,IAAI,CAAC,EAAE,CAAC;QAC3B,oBAAoB,EAAE,CAAC;IAC3B,CAAC;AACL,CAAC,CAAC;AAEF,2FAA2F;AAC3F,MAAM,aAAa,GAAG,CAAC,GAA8B,EAAE,EAAE;IACrD,IAAI,CAAC,MAAM,EAAE,CAAC;QACV,OAAO;IACX,CAAC;IAED,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC,4BAA4B,EAAE,CAAC;IACrE,IAAI,CAAC,UAAU,EAAE,CAAC;QACd,OAAO;IACX,CAAC;IAED,4FAA4F;IAC5F,mBAAmB;IACnB,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,SAAS,IAAI,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;IAErE,8BAA8B;IAC9B,MAAM,cAAc,GAAG,OAAO,GAAG,UAAU,CAAC,IAAI,CAAC;IACjD,MAAM,cAAc,GAAG,OAAO,GAAG,UAAU,CAAC,GAAG,CAAC;IAEhD,IAAI,sBAAgE,CAAC;IACrE,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,cAAc,EAAE,cAAc,EAAE,CAAC,IAAI,EAAE,EAAE;QACpE,8EAA8E;QAC9E,gEAAgE;QAChE,MAAM,sBAAsB,GAAG,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC3D,OAAO,IAAI,CAAC,SAAS,EAAE,IAAI,OAAO,sBAAsB,KAAK,WAAW,IAAI,sBAAsB,CAAC,sBAAsB,CAAC;IAC9H,CAAC,CAAC,CAAC;IAEH,IAAI,UAA+B,CAAC;IACpC,IAAI,UAAU,CAAC,GAAG,EAAE,CAAC;QACjB,UAAU,GAAG,UAAU,CAAC,UAAU,CAAC;IACvC,CAAC;SAAM,CAAC;QACJ,UAAU,GAAG,IAAI,CAAC;IACtB,CAAC;IAED,MAAM,gBAAgB,GAAG,QAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,CAAC,CAAC;IAE1D,+DAA+D;IAC/D,IAAI,UAAU,IAAI,UAAU,CAAC,QAAQ,KAAK,gBAAgB,EAAE,CAAC;QACzD,OAAO;IACX,CAAC;IAED,4EAA4E;IAC5E,6CAA6C;IAC7C,IAAI,gBAAgB,IAAI,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,QAAQ,KAAK,gBAAgB,CAAC,EAAE,CAAC;QAChF,cAAc,EAAE,CAAC;IACrB,CAAC;IAED,8EAA8E;IAC9E,6EAA6E;IAC7E,iBAAiB;IACjB,IAAI,UAAU,EAAE,CAAC;QACb,sBAAsB,GAAG,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAC3D,sBAAuB,CAAC,oBAAoB,EAAE,CAAC;IACnD,CAAC;AACL,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,OAAO,4BAA4B;IAQrC;;OAEG;IACH,IAAW,YAAY;QACnB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC9B,CAAC;IAED,IAAW,YAAY,CAAC,KAA0B;QAC9C,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;IAC/B,CAAC;IAED,YACY,gBAA4B,EAC5B,gBAA4B,EACpC,EAAE,qBAAqB,GAAG,IAAI,EAAE,GAAG,EAAE;QAF7B,qBAAgB,GAAhB,gBAAgB,CAAY;QAC5B,qBAAgB,GAAhB,gBAAgB,CAAY;QApBxC,mCAAmC;QAC5B,SAAI,GAAG,8BAA8B,CAAC;QAsBzC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAC1B,IAAI,CAAC,sBAAsB,GAAG,qBAAqB,CAAC;QAEpD,kCAAkC;QAClC,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,CAAC;YAClC,MAAM,CAAC,IAAI,CAAC,yGAAyG,CAAC,CAAC;QAC3H,CAAC;IACL,CAAC;IAED;;OAEG;IACH,IAAW,qBAAqB,CAAC,qBAA8B;QAC3D,IAAI,IAAI,CAAC,sBAAsB,KAAK,qBAAqB,EAAE,CAAC;YACxD,OAAO;QACX,CAAC;QACD,IAAI,CAAC,sBAAsB,GAAG,qBAAqB,CAAC;QACpD,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACrB,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;gBAC9B,mBAAmB,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAG,CAAC,CAAC;YACxD,CAAC;iBAAM,CAAC;gBACJ,kBAAkB,EAAE,CAAC;YACzB,CAAC;QACL,CAAC;IACL,CAAC;IAED;;OAEG;IACI,IAAI,KAAI,CAAC;IAEhB;;;OAGG;IACI,MAAM,CAAC,IAAkB;QAC5B,4EAA4E;QAC5E,6EAA6E;QAC7E,0EAA0E;QAC1E,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,iBAAiB,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAClC,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC9B,mBAAmB,CAAC,IAAI,CAAC,QAAQ,EAAG,CAAC,CAAC;QAC1C,CAAC;IACL,CAAC;IAED;;OAEG;IACI,MAAM;QACT,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;YACrB,OAAO;QACX,CAAC;QACD,sDAAsD;QACtD,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC5C,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC9B,kBAAkB,EAAE,CAAC;QACzB,CAAC;QACD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;IAC7B,CAAC;IAED;;OAEG;IACI,OAAO;QACV,IAAI,CAAC,MAAM,EAAE,CAAC;IAClB,CAAC;IAED,yBAAyB;IAClB,oBAAoB;QACvB,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;YACrB,OAAO;QACX,CAAC;QACD,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC1D,CAAC;IAED,yBAAyB;IAClB,oBAAoB;QACvB,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;YACrB,OAAO;QACX,CAAC;QACD,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACxG,CAAC;CACJ","sourcesContent":["import type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Behavior } from \"core/Behaviors/behavior\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { requestCapture, requestRelease, releaseCurrent, getCapturingId } from \"./pointerEventsCapture\";\r\n\r\n// Module level variable for holding the current scene\r\nlet _scene: Scene | null = null;\r\n\r\n// Module level variable to hold the count of behavior instances that are currently capturing pointer events\r\n// on entry.  This is used to determine if we need to start or stop observing pointer movement.\r\nlet captureOnEnterCount = 0;\r\n\r\n// Map used to store instance of the PointerEventsCaptureBehavior for a mesh\r\n// We do this because this gets checked on pointer move and we don't want to\r\n// use getBehaviorByName() because that is a linear search\r\nconst meshToBehaviorMap = new WeakMap<AbstractMesh, PointerEventsCaptureBehavior>();\r\n\r\nconst startCaptureOnEnter = (scene: Scene) => {\r\n    // If we are not in a browser, do nothing\r\n    if (typeof document === \"undefined\") {\r\n        return;\r\n    }\r\n    if (captureOnEnterCount === 0) {\r\n        document.addEventListener(\"pointermove\", onPointerMove);\r\n        document.addEventListener(\"touchstart\", onPointerMove);\r\n        _scene = _scene ?? scene;\r\n        Logger.Log(\"PointerEventsCaptureBehavior: Starting observation of pointer move events.\");\r\n        _scene.onDisposeObservable.add(doStopCaptureOnEnter);\r\n    }\r\n    captureOnEnterCount++;\r\n};\r\n\r\nconst doStopCaptureOnEnter = () => {\r\n    document.removeEventListener(\"pointermove\", onPointerMove);\r\n    document.removeEventListener(\"touchstart\", onPointerMove);\r\n    _scene = null;\r\n    Logger.Log(\"PointerEventsCaptureBehavior: Stopping observation of pointer move events.\");\r\n    captureOnEnterCount = 0;\r\n};\r\n\r\nconst stopCaptureOnEnter = () => {\r\n    // If we are not in a browser, do nothing\r\n    if (typeof document === \"undefined\") {\r\n        return;\r\n    }\r\n\r\n    // If we are not observing pointer movement, do nothing\r\n    if (!_scene) {\r\n        return;\r\n    }\r\n\r\n    captureOnEnterCount--;\r\n    if (captureOnEnterCount <= 0) {\r\n        doStopCaptureOnEnter();\r\n    }\r\n};\r\n\r\n// Module level function used to determine if an entered mesh should capture pointer events\r\nconst onPointerMove = (evt: PointerEvent | TouchEvent) => {\r\n    if (!_scene) {\r\n        return;\r\n    }\r\n\r\n    const canvasRect = _scene.getEngine().getRenderingCanvasClientRect();\r\n    if (!canvasRect) {\r\n        return;\r\n    }\r\n\r\n    // Get the object that contains the client X and Y from either the pointer event or from the\r\n    // TouchEvent touch\r\n    const { clientX, clientY } = \"touches\" in evt ? evt.touches[0] : evt;\r\n\r\n    // get the picked mesh, if any\r\n    const pointerScreenX = clientX - canvasRect.left;\r\n    const pointerScreenY = clientY - canvasRect.top;\r\n\r\n    let pointerCaptureBehavior: PointerEventsCaptureBehavior | undefined;\r\n    const pickResult = _scene.pick(pointerScreenX, pointerScreenY, (mesh) => {\r\n        // If the mesh has an instance of PointerEventsCaptureBehavior attached to it,\r\n        // and capture on pointer enter is true, then we want to pick it\r\n        const pointerCaptureBehavior = meshToBehaviorMap.get(mesh);\r\n        return mesh.isEnabled() && typeof pointerCaptureBehavior !== \"undefined\" && pointerCaptureBehavior._captureOnPointerEnter;\r\n    });\r\n\r\n    let pickedMesh: AbstractMesh | null;\r\n    if (pickResult.hit) {\r\n        pickedMesh = pickResult.pickedMesh;\r\n    } else {\r\n        pickedMesh = null;\r\n    }\r\n\r\n    const capturingIdAsInt = parseInt(getCapturingId() || \"\");\r\n\r\n    // if the picked mesh is the current capturing mesh, do nothing\r\n    if (pickedMesh && pickedMesh.uniqueId === capturingIdAsInt) {\r\n        return;\r\n    }\r\n\r\n    // If there is a capturing mesh and it is not the current picked mesh, or no\r\n    // mesh is picked, release the capturing mesh\r\n    if (capturingIdAsInt && (!pickedMesh || pickedMesh.uniqueId !== capturingIdAsInt)) {\r\n        releaseCurrent();\r\n    }\r\n\r\n    // If there is a picked mesh and it is not the current capturing mesh, capture\r\n    // the pointer events.  Note that the current capturing mesh has already been\r\n    // released above\r\n    if (pickedMesh) {\r\n        pointerCaptureBehavior = meshToBehaviorMap.get(pickedMesh);\r\n        pointerCaptureBehavior!.capturePointerEvents();\r\n    }\r\n};\r\n\r\n/**\r\n * Behavior for any content that can capture pointer events, i.e. bypass the Babylon pointer event handling\r\n * and receive pointer events directly.  It will register the capture triggers and negotiate the capture and\r\n * release of pointer events.  Curerntly this applies only to HtmlMesh\r\n */\r\nexport class PointerEventsCaptureBehavior implements Behavior<AbstractMesh> {\r\n    /** gets or sets behavior's name */\r\n    public name = \"PointerEventsCaptureBehavior\";\r\n\r\n    private _attachedMesh: AbstractMesh | null;\r\n    /** @internal */\r\n    public _captureOnPointerEnter: boolean;\r\n\r\n    /**\r\n     * Gets or sets the mesh that the behavior is attached to\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n\r\n    public set attachedMesh(value: AbstractMesh | null) {\r\n        this._attachedMesh = value;\r\n    }\r\n\r\n    constructor(\r\n        private _captureCallback: () => void,\r\n        private _releaseCallback: () => void,\r\n        { captureOnPointerEnter = true } = {}\r\n    ) {\r\n        this._attachedMesh = null;\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n\r\n        // Warn if we are not in a browser\r\n        if (typeof document === \"undefined\") {\r\n            Logger.Warn(`Creating an instance of PointerEventsCaptureBehavior outside of a browser.  The behavior will not work.`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set if the behavior should capture pointer events when the pointer enters the mesh\r\n     */\r\n    public set captureOnPointerEnter(captureOnPointerEnter: boolean) {\r\n        if (this._captureOnPointerEnter === captureOnPointerEnter) {\r\n            return;\r\n        }\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n        if (this._attachedMesh) {\r\n            if (this._captureOnPointerEnter) {\r\n                startCaptureOnEnter(this._attachedMesh.getScene()!);\r\n            } else {\r\n                stopCaptureOnEnter();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function called when the behavior needs to be initialized (before attaching it to a target)\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Called when the behavior is attached to a target\r\n     * @param mesh defines the target where the behavior is attached to\r\n     */\r\n    public attach(mesh: AbstractMesh) {\r\n        // Add a reference to this behavior on the mesh.  We do this so we can get a\r\n        // reference to the behavior in the onPointerMove function without relying on\r\n        // getBehaviorByName(), which does a linear search of the behaviors array.\r\n        this.attachedMesh = mesh;\r\n        meshToBehaviorMap.set(mesh, this);\r\n        if (this._captureOnPointerEnter) {\r\n            startCaptureOnEnter(mesh.getScene()!);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when the behavior is detached from its target\r\n     */\r\n    public detach() {\r\n        if (!this.attachedMesh) {\r\n            return;\r\n        }\r\n        // Remove the reference to this behavior from the mesh\r\n        meshToBehaviorMap.delete(this.attachedMesh);\r\n        if (this._captureOnPointerEnter) {\r\n            stopCaptureOnEnter();\r\n        }\r\n        this.attachedMesh = null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the behavior\r\n     */\r\n    public dispose() {\r\n        this.detach();\r\n    }\r\n\r\n    // Release pointer events\r\n    public releasePointerEvents() {\r\n        if (!this.attachedMesh) {\r\n            return;\r\n        }\r\n        requestRelease(this.attachedMesh.uniqueId.toString());\r\n    }\r\n\r\n    // Capture pointer events\r\n    public capturePointerEvents() {\r\n        if (!this.attachedMesh) {\r\n            return;\r\n        }\r\n        requestCapture(this.attachedMesh.uniqueId.toString(), this._captureCallback, this._releaseCallback);\r\n    }\r\n}\r\n"]}